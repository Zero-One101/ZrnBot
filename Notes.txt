<ZeroOne>	Well, time to create the Message object
 *	SkreeBot (~SkreeBot@---.dhcp.leds.al.charter.com) has joined #sr
<SkreeBot>	Command token for this channel is &
 *	ChanServ sets modes [#sr +o SkreeBot]
 *	SkreeBot has quit (Read error Connection reset by peer)
<PY>	you should probably just create whatever channel when you get a message from it
<Silver_Skree>	I do
<ZeroOne>	I wonder if I should have message subtypes to identify if it's a server message or not
<Silver_Skree>	I recently rewrote the section that happens in
<Silver_Skree>	and forgot to add LBYL
<PY>	LBYL?
<Silver_Skree>	Look Before You Leap
<Silver_Skree>	check if my channel dict has an entry for this channel
<Silver_Skree>	if not, make one
<Silver_Skree>	THEN access the dict
<Silver_Skree>	as opposed to EAFTP
<Silver_Skree>	Easier to Ask Forgiveness Than Permission
<Silver_Skree>	try access
<Silver_Skree>	on KeyError, make entry
<PY>	yes, I'm aware of the terms v
<Silver_Skree>	yeah, I think you taught them to me
<Silver_Skree>	was wondering why you asked
<PY>	didn't immediately grok the acronym
<ZeroOne>	I love how I can never remember how to write enums
<Silver_Skree>	why is the chanObj for the query None
<Silver_Skree>	what the fuck
<Silver_Skree>	oh wait
<Silver_Skree>	no I know
<Silver_Skree>	I'm relating the line to its channel object inside of the network object
<Silver_Skree>	but when a line's channel string isn't in the network object's channel dictionary keys, I disregard it
<Silver_Skree>	I'm not sure why
<ZeroOne>	I love me some ReSharper.
<Silver_Skree>	the big advantage ZeroOne has over me is the ability to set up a real debug environment and step through operations and view memory >_>
 *	Silver_Skree misses these things
<ZeroOne>	Yeah, and I don't even have to connect to IRC to test things.
<PY>	you could use a python debugger, skree<.<
<Silver_Skree>	you've already got your mock network set up?
<ZeroOne>	Not yet
<ZeroOne>	I'm currently writing the Message object
<Silver_Skree>	of course, my advantage is my abundance of free time 
<ZeroOne>	I don't have to do shit until next Friday P
<Silver_Skree>	BOT RAAAAAAAACE
<ZeroOne>	Your advantage is you actually work on it.
<Silver_Skree>	I started two days ago
<Silver_Skree>	don't count me in for the long run yet
<ZeroOne>	Heh
<ZeroOne>	You also have the benefit of knowing Python better than I do
<Silver_Skree>	but still, only two days and I'm this far along
<ZeroOne>	My core is C#, but most of my functionality will end up being Python scripts
<Silver_Skree>	despite some of the less tasteful practices, this is the most productive I've been with code since I wrote my dumb little slideshow program
<ZeroOne>	Whoa. Last time I worked on ZrnBot was  days ago
<Silver_Skree>	even Simplex wasn't cranked out this fast at first
<ZeroOne>	And that was just adding save/load functionality
<Silver_Skree>	I still need to add that
<Silver_Skree>	I'm not logging and there's no config
<Silver_Skree>	but right now I'm sidetracked on not making him crash on CTCP
<ZeroOne>	[Serializable] make it really trivial in C#
<ZeroOne>	makes*
<Silver_Skree>	presumably he would have also crashed on query
<Silver_Skree>	just, nobody queried him
<Silver_Skree>	also, I want to try something
 *	Silver_Skree test
<ZeroOne>	Ok, time to parse the incoming message and split it up into all of its components
<Silver_Skree>	aw
<Silver_Skree>	gotta love that non-linear development
<ZeroOne>	Jumping around the various tasks you need to do and hope it all comes together?
<Silver_Skree>	hehe
<ZeroOne>	I should've actually made a diagram of this. Some sort of documentation.
<Silver_Skree>	what I meant is that I just hurried into connecting to IRC, responding to pings, and joining channels
<Silver_Skree>	and then polished from there
<ZeroOne>	Ah
<ZeroOne>	Yep, that was my first bot.
<Silver_Skree>	you seem to have handled saving, loading, etc. first
<ZeroOne>	My first bot was also made in entirely two classes.
<Silver_Skree>	heh
<ZeroOne>	I think the save thing was just me being lazy. Doing that means I don't have to input all of the same connection details every time, or hardcode it.
<ZeroOne>	Instead, "oh look, it's a file. Let's cast it to a Bot object."
<ZeroOne>	boom, done
<Silver_Skree>	in other news, this Beloved Tomboyish Daughter arrangement sounds a bit like Stickerbush Symphony, actually
<Silver_Skree>	weird
<ZeroOne>	...maybe a ServerMessage subtype wouldn't be a bad idea
<ZeroOne>	Python can check what type something is, right? Like if (input is type)?
<PY>	yes, of course
<ZeroOne>	type(input) is ServerMessage
<ZeroOne>	This requires some consideration
<ZeroOne>	It also requires access to a lot of the data that the Bot class stores. I could either pass the Bot to the Message constructor, or only the information the Message needs (control char, server name, bot name)
<PY>	why does your message type need to know about your bot?
<ZeroOne>	It doesn't
<ZeroOne>	It only really needs to know those things I listed
<PY>	why does it need to know those?
<ZeroOne>	The control char to determine if it's a command, the server to determine if it's a server message, and the bot name to determine if it's a query
<PY>	perhaps the message type shouldn't also be responsible for doing that sort of parsing?
<ZeroOne>	It shouldn't?
 *	KentaTworodani has quit (Ping timeout  seconds)
<PY>	it's often worth restructuring things so that things don't need to know about other things!
<ZeroOne>	This is true
<ZeroOne>	If I push this to GitHub, could you have a look at it and suggest things?
<PY>	am a little busy right now, unforortunately (
<ZeroOne>	sadface
<ZeroOne>	ok
<ZeroOne>	Think it's worth getting rid of the namespaces I'm not using?
<PY>	if you aren't using them!
<ZeroOne>	Whee
<ZeroOne>	I am mostly namespaceless.
<ZeroOne>	% of my files now no longer have any namespaces.
<PY>	in c#?
<ZeroOne>	Yeah
<PY>	literally did not realise you could do that
<PY>	not sure why you would x
<ZeroOne>	Well, you said "if you aren't using them!"
<Silver_Skree>	mmmmmm chocolate mint cookies
<PY>	I thought you meant they were empty!
<ZeroOne>	And according to ReSharper, half the time I wasn't even using the System namespace
<PY>	/oh/
<ZeroOne>	The using statements
<PY>	importing namespaces, right.
<ZeroOne>	Those namespaces
<PY>	yeah
<PY>	get rid of those v
<PY>	I thought you meant for your own code
<ZeroOne>	I don't have a ZrnBot.whatever namespace
<ZeroOne>	I am not yet pro enough for that
<PY>	you should make one
<ZeroOne>	Hmm. I haven't properly considered where my Network object would go in relation to everything else
<PY>	is this for your mock?
<ZeroOne>	Or rather the IO object
<Silver_Skree>	okay, after spacing out and eating cookies for  minutes, SkreeBot no longer crashes on query.
<ZeroOne>	In general. Mock IO and actual IRC IO
<PY>	Zrnbot.IO would make sense. INetwork and IRCNetwork in Zrnbot.IO, MockNetwork in Zrnbot.Test.IO
<ZeroOne>	Oh boy, subnamespaces!
<ZeroOne>	...that's not the technical term, is it?
<PY>	they're just namespaces
<ZeroOne>	Ah
<ZeroOne>	But I'm also talking about the path an input takes through my code
<ZeroOne>	Program instantiates ConsoleUI, which instantiates the Bot
<ZeroOne>	I get an input through the IO object
<PY>	you generally want to be able to inject things you want to be able to mock
<ZeroOne>	Dependency injection
<PY>	yeah
<PY>	simplest method is just taking an INetwork in the ctor
<ZeroOne>	Now, I want to pass this input to my UI so it can be displayed
<PY>	define input here
<ZeroOne>	I also want to pass it to my Bot so it can be converted into a Message and then acted upon
<ZeroOne>	Either mock or IRC message
<ZeroOne>	Server or user
<PY>	right
<PY>	how do you think INetwork could look?
<ZeroOne>	Remind me of what I can define in an interface
<ZeroOne>	I keep getting interfaces and abstract classes confused
<PY>	properties, methods, events, I think delegates
<ZeroOne>	Well, it'd probably want InStream and OutStream properties, to send and receive data
<PY>	Possibly, but will that let you do what you want?
<ZeroOne>	What I want is to pass the relevant information to my UI and my Bot, right?
<PY>	right
<ZeroOne>	So it'd probably also want to hold a reference to the UI and the bot
<ZeroOne>	But no
<ZeroOne>	It doesn't need to know about those things, right?
<PY>	the best design might actually know about those things, just not specifically what they are
<ZeroOne>	How does that work?
<PY>	I'm mostly thinking of using events, which I'm not sure you've covered before?
<ZeroOne>	I've done events in my Mario engine
<ZeroOne>	Haven't applied it to non-game things, but I imagine it's the same
<PY>	oh, goodie
<PY>	can you see how it could apply here?
<ZeroOne>	When IRCNetwork receives an input, it fires off an event that both the ConsoleUI and the Bot are subscribed to
<PY>	right!
<ZeroOne>	Or perhaps separate events
<PY>	what for?
<ZeroOne>	It doesn't matter, does it
<PY>	I dunno what you want them for
<ZeroOne>	Well the UI needs the message to display it to the console
<ZeroOne>	The bot needs it to create the Message object and then do stuff with it
<ZeroOne>	But they both act on receiving a message
<ZeroOne>	So the same event should work
<PY>	yep
<ZeroOne>	It'd have two subscribers
<PY>	or however many!
<ZeroOne>	Right
<ZeroOne>	Amusingly, while all of this solves a lot of problems, it doesn't solve the original question. What should actually parse the message, if not the Message object
<ZeroOne>	IRCNetwork shouldn't do it.
<ZeroOne>	Maybe Bot
<PY>	maybe. You could do multi-pass? Give the IRCNetwork an IRCMessageParser that knows how to turn messages into naive IRCMessages
<PY>	then the bot can inform further categorisation
<ZeroOne>	So IRCNetwork receives an input
<ZeroOne>	It then passes it to IRCMessageParse that returns an IRCMessage
<ZeroOne>	THEN it fires the event that both UI and Bot are subscribed to
<PY>	sounds like it could work!
<ZeroOne>	And then Bot could take it further and say "Ok, this is a ServerMessage" or "Ok, this is a UserMessage"
 *	MenTaLguY has quit (Ping timeout  seconds)
<PY>	right, the bot needs to be responsible for routing 
<ZeroOne>	Now, IRCMessage wouldn't simply be the raw input, but it /could/ contain it
<PY>	there's a lot of structure you can give just an irc message
<ZeroOne>	True, but I also have to keep it quite generic. I should only use the things common to ALL IRC messages, server and user
<PY>	right, but that's still a lot
<ZeroOne>	Also, I like how you're busy, but you're still helping
<PY>	I can do some degree of multitasking!
<ZeroOne>	Hahaha
<ZeroOne>	Py.HelpThread
<ZeroOne>	Py.WorkThread is await
<ZeroOne>	"Namespace does not correspon to file location, should be 'ZrnBot'"
<ZeroOne>	I take it ReSharper is suggesting I have an IO folder inside my ZrnBot folder
<PY>	yeah
<ZeroOne>	Ah.
<ZeroOne>	And, of course, Io*
...
<katsu>	Also, about the namespaces
<katsu>	ZrnBot.IO is correct
<ZeroOne>	Oh
<katsu>	ZrnBot.Io is not
<katsu>	acronyms less than three characters are kept all caps
<ZeroOne>	Ah, ok
<katsu>	See System.IO
<katsu>	Now the shitty thing is if you have a two letter acronym followed by a word
<katsu>	IOHandler
<katsu>	that's the proper name
<katsu>	but it might look a bit odd
...
<katsu>	For the IRC library I had been working on, I completely abstracted out the network IO
<katsu>	https//github.com/nehresmann/Nyaxix.Irc/blob/master/Nyaxix.Irc/IConnection.cs
<katsu>	Literally just an event that would fire when stuff comes in and a function to call to send stuff out
<ZeroOne>	Ah
<katsu>	but that was generic IRC library
<katsu>	Also, the rest of that code is old
...
<ZeroOne>	...this doesn't seem like it should work
<ZeroOne>	"public IrcMessage IrcMessage"
<ZeroOne>	And yet, neither ReSharper or VS is telling me off.
<katsu>	Nope, it can determine type vs identifier based on the grammar
<ZeroOne>	Yeah, I just realised I'd be accessing that by doing something like event.IrcMessage
<ZeroOne>	IrcMessage is clearly not a class in this case
<katsu>	It could become dicy if you had a static property called IrcMessage and also an internal class called IrcMessage, but even then the parser can figure it out
<ZeroOne>	I think at that point, I might want to consider renaming a couple of things
<ZeroOne>	Should my INetwork have properties for an input stream and an output stream, or would I just be sending and receiving through the same stream here? NetworkStream, I imagine
<PY>	you're probably thinking too low level
<PY>	you want to distribute one stream across n clients, you can't expose the raw stream
<PY>	otherwise you'll get the UI picking up one message and the bot picking up another, and never the twain shall meet
<ZeroOne>	So this interface would provide methods for sending and receiving, but the ACTUAL stream stuff is done elsewhere?
<katsu>	So my setup was an IConnection
<katsu>	It states that an event is fired when data comes in, providing a string of the data
<PY>	katsu's setup is basically what I was going to try and lead you towards
<katsu>	and allows data to be sent out, as a string
<katsu>	You'd have one IConnection per IRC network you're connected to
<PY>	you need something on that level of abstraction, you can't think in streams if you want to split it like that
<katsu>	You could possibly aggregate all of them into a single interface though
<katsu>	Could possibly be useful, but I'd rather aggregate as another layer
<ZeroOne>	So how should I do this
<ZeroOne>	I'm guessing my INetwork interface would essentially be your IConnection interface
<katsu>	So yeah, I'll try to explain the abstractions I was thinking of
<katsu>	At the lowest level, you've got the network io
<katsu>	but IRC shouldn't have to care about that
<katsu>	So what does it need?
<katsu>	It needs to know when a message is received
<katsu>	and it needs to be able to send data
<katsu>	It doesn't care how
<ZeroOne>	For which I have a MessageReceivedEventArgs
<katsu>	the second thing is that IRC is all string-based communication
<katsu>	So you don't need the complexities of having to send byte arrays and whatnot
<katsu>	From that information, you have an event and a method
<katsu>	I've tacked on a bit more info because of multi-network stuff
<katsu>	but for now ignore that
<katsu>	the Url and Server is not important
<ZeroOne>	brb, dad wants me. Keep talking, I'll catch up
<katsu>	Now, once you have that, you need something to receive messages and handle the messages that arrive
<katsu>	and by handle messages, this may involve sending responses
<katsu>	This becomes more complex, because "handling" a "message" is not trivial
<katsu>	what is a message?
<katsu>	we need to make it simpler
<katsu>	A message needs to be defined
<katsu>	So in my method, I went type crazy
<katsu>	definitely not a requirement
<katsu>	you can go much simpler and move some of that logic over to the handlers
<katsu>	but that's getting ahead of myself
<katsu>	This is where we get into IRC RFC
<katsu>	You need something to abstract that
<katsu>	the format of an IRC message
<katsu>	break it down into components
<PY>	here comes the regex
<katsu>	IRC RFC defines these things as the message prefix, message command, and message parameters (with a special case for the trailing parameter)
<katsu>	and the prefix is further defined
<katsu>	So I created two classes
<katsu>	Message and Prefix
<katsu>	These could be structs
<katsu>	they simply contain data and some light logic to reformat themselves for output
<katsu>	keep in mind that object construction is always best left to factory classes
<katsu>	Message and Prefix contain the data we want out of an irc message
<katsu>	and we have a MessageFactory to build Messages
<katsu>	(please keep in mind you also want an interface for MessageFactory for unit testing purposes)
<katsu>	You don't necessarily need interfaces for Message and Prefix
<katsu>	you could treat them like primitives
<katsu>	just don't start putting super complex logic in them
<katsu>	If they're primitives, then keep them that way
<katsu>	Also PY, I'll skip the regex, that's implementation detail, not design
<PY>	haha
<katsu>	So once you've got a MessageFactory to provide you with Message objects from the strings received from an IConnection, you can begin to work with them
<katsu>	I went further and built ICommand objects from those, but that may not be desirable
<katsu>	that's a lot of types
<katsu>	so I'll skip that for now
<katsu>	These messages are all handled differently based on what they are
<katsu>	PING messages need a PONG message response generated and sent out
<katsu>	when you join a channel, you'll get NAMES messages
<katsu>	and so on
 *	KentaTworodani (~Kenta-PC@---.res.bhn.net) has joined #sr
 *	ChanServ sets modes [#sr +o KentaTworodani]
<katsu>	Just like we don't want to know how to create a Message from a raw irc string in this class (for now we'll call it the IrcClient), we don't want to know about how a message is handled
<katsu>	There are many, many IRC commands
<katsu>	and we may want to be able to tackle them in one or more handlers so we can separate concerns
<katsu>	This is the chain of responsibility pattern
<ZeroOne>	I quite like the idea of Message and Prefix classes/structs
<ZeroOne>	It'd give me some experience with the Factory pattern
<katsu>	I'll give you some help with the factory pattern
<katsu>	Wtih MessageFactory, you're gonna want a simple interface
<katsu>	With, even
<ZeroOne>	Much appreciated
<katsu>	Message BuildMessage(string ircMessage);
<PY>	like many patterns, the factory pattern is an amazingly simple concept
<katsu>	my bad, let me give you the whole interface
<katsu>	interface IMessageFactory
<katsu>	{
<katsu>	    Message BuildMessage(string ircMessage);
<katsu>	}
<katsu>	there you go
<ZeroOne>	Hahaha
<PY>	that literally is all it is
<ZeroOne>	Is that literally the Factory pattern?
<ZeroOne>	Wow
<PY>	yes
<ZeroOne>	That's nothing
<katsu>	but so powerful
<PY>	and for all that you get a lot of desirable behaviour
<ZeroOne>	why hasn't this been covered in uni argh
<katsu>	I'll actually make one change and you'll see why it is incredbily powerful
<katsu>	interface IMessageFactory
<katsu>	{
<katsu>	    IMessage BuildMessage(string ircMessage);
<katsu>	}
<katsu>	Now you have a factory that returns an /interface/
<katsu>	This is where factories truly become powerful
<PY>	even better, a factory /interface/ that returns an interface
<PY>	if you have an IMessageFactory you can have no goddamn idea how it does what it does, and that's super neat
<katsu>	Yes, so you can mock your factory in unit tests to return a mock message
<ZeroOne>	That is absolutely ridiculous
<ZeroOne>	I love it
<katsu>	For the Message, where it's almost a primitive, the factory is only marginally useful
<ZeroOne>	There's a lot of information being thrown at me here and I'm not sure where to start. I'm fairly certain my bot already needs a good deal of refactoring
<katsu>	for the part where I created a billion IRC command types, it became insanely useful
<katsu>	interface ICommandFactory
<katsu>	{
<katsu>	    ICommand BuildCommand(IMessage message);
<katsu>	}
<katsu>	So now your factory interface has a method that takes an interface and returns an interface
<ZeroOne>	So factories are exceptionally good at cranking out a lot of the same type
<katsu>	So I'll draw it out right now
<PY>	factories are good when you need to abstract the details of how you actually make something. Whether because how you do that is complex, because you need to be able to test what happens to what it produces, or whatever, the core point of a factory is that it abstracts away that new
<ZeroOne>	Ooh, so anything that implements ICommandFactory will be able to call BuildCommand and pass it anything that implements the IMessage interface
<ZeroOne>	And BuildCommand will do whatever that specific class requires it to do
<PY>	anything which /has/ something that implements ICommandFactory
<katsu>	Working on a diagram
<PY>	in katsu's case, his primary implementation is going to abstract away all the nasty routing involved in turning an IRC message into an IRC command
<PY>	that logic isn't something you want everyone to have to know about
<PY>	it may be logic which changes depending on who's calling it
<PY>	it's certainly logic that you might need to test
<katsu>	Right, but in my system there's a nasty issue where the handler still needs to know the actual ICommand type
<katsu>	It's not perfect, but it works
<katsu>	It boils down to a handler doing
<katsu>	var ping = command as Ping;
<katsu>	if (ping != null)
<katsu>	{ /* do things */ }
<ZeroOne>	BTW, unrelated, but in my Mario engine, I'm having Mario checking the type of whatever he collided with to determine how he should react. Can this be better written using the visitor pattern?
<katsu>	Here we go
<katsu>	https//dl.dropboxusercontent.com/u//irc/interface_overview.png
<ZeroOne>	fancy
<katsu>	Notice something interesting
<ZeroOne>	IMessage is at the centre of it all?
<katsu>	The only thing that relies on a concrete class is the factory
<ZeroOne>	The concrete class being the IrcClient?
<katsu>	IrcClient is a concrete class
<katsu>	but it only relies on interfaces
<ZeroOne>	Oh, yes
<katsu>	IConnection, IMessageFactory, IMessage, and IMessageHandler
<ZeroOne>	Message is the concrete class
<katsu>	also, I did make a mistake in the diagram
<ZeroOne>	*gasp*
<katsu>	I forgot that IMessageFactory doesn't rely on Message
<ZeroOne>	faaaaart
<ZeroOne>	Should I just ignore that line?
<katsu>	There should be a class called MessageFactory, which relies on IMessageFactory, IMessage, and Message
<katsu>	Updated, refresh
<katsu>	anyways, that's the basic idea
<ZeroOne>	So MessageFactory holds a reference to Message, IMessageFactory and IMessage?
<katsu>	MessageFactory implements IMessageFactory
<katsu>	IMessageFactory declares a method that returns IMessage
<katsu>	so by implementing IMessageFactory, MessageFactory also relies on the IMessage interface
<katsu>	MessageFactory builds an instance of Message and returns that
<ZeroOne>	Right
<katsu>	So by building an instance of Message, it has to rely on it too
<katsu>	and by rely, I mean it is "coupled" to its implementation
<katsu>	well, its interface
<katsu>	If the Message constructor changed, MessageFactory has to change to adapt
<katsu>	but anything relying on IMessage won't have to change
<katsu>	So IrcClient, for instance
<katsu>	If you change Message, IrcClient doesn't have to change
<katsu>	Those two components observe loose coupling
<katsu>	IrcClient and MessageFactory are also loosely coupled
<ZeroOne>	So I'm looking to implement this sort of thing in my bot
<katsu>	Yeah
<katsu>	The key is to know where to break down a problem into pieces and abstract those pieces away
<katsu>	So we have the IrcClient
<katsu>	What are its responsibilities?
<katsu>	at a high level, it receives messages and handles them
<katsu>	good, stop there
<katsu>	that's what IrcClient does
<katsu>	How does IrcClient do those things?
<katsu>	those are new interfaces that it uses
<katsu>	Designing your application in this way puts all of the tight coupling in two distinct places
<katsu>	. In the factory classes
<katsu>	. In the application start method
<katsu>	and there are a lot of crazy tools to remove the second one
<katsu>	but I won't get into that
<katsu>	If you've designed your application like this, you can do that later
<ZeroOne>	Haha. Yeah, this stuff is complex enough as it is P
<katsu>	You go down this road far enough, you may need a FactoryFactory
<katsu>	Not for this application specifically
<ZeroOne>	A factory that creates factories
<katsu>	an IRC client probably isn't complex enough for that
<ZeroOne>	I'm giggling, honestly.
<katsu>	I usually call those providers
<katsu>	but that's me
<ZeroOne>	But they're essentially the same?
<katsu>	yeah
<katsu>	they're a factory that creates factories
<katsu>	This one isn't really a factory
<katsu>	but an example
<katsu>	https//github.com/nehresmann/Nyaxix.Serialization/blob/master/Nyaxix.Serialization/SerializationFactoryProvider.cs
<katsu>	This holds instances of factories, it doesn't build them
<katsu>	I did forget the where clause on the generics though
<katsu>	should have included
<katsu>	"where T  ISerializationFactory"
 *	Black_Falcon has quit (Quit Connection reset by beer.)
<ZeroOne>	fucker that's my quit message
<ZeroOne>	Oh, no it's not.
<ZeroOne>	never mind.
<katsu>	err, not quite
<katsu>	I mean
<katsu>	I think that is defined correctly
<katsu>	it's been a while
<katsu>	T was the type of object to serialize/deserialize
<katsu>	which could be anything
<katsu>	I enforced what could be sent via the method parameter
<katsu>	ISerializationFactory<T>
<ZeroOne>	So it's a way for serialising/deserialising damn near anything
<ZeroOne>	But, generically
<katsu>	meeting time
<katsu>	and yes
<ZeroOne>	dangit
<ZeroOne>	Have fun in the meeting
<ZeroOne>	I need to consider what I'm going to need to refactor here
<katsu>	You just have to define an ISerializationFactory<T> object for some type T, then give it to this provider
<ZeroOne>	Which is probably everything
<katsu>	and then pass the provider to the serialization or deserialization process
<katsu>	You can look at that entire project to see how it works
<katsu>	https//github.com/nehresmann/Nyaxix.Serialization/tree/master/Test.Nyaxix.Serialization
<ZeroOne>	True, but I learn far better by doing it as opposed to reading it
<katsu>	look at the test to see how it is used
<ZeroOne>	Which always has me in the loop of "If I do it, I'll learn it, but to do it, I need to learn how to do it"
<katsu>	heh
<katsu>	anyways, back in a bit
<ZeroOne>	hence why I'm usually pestering PY for a line-by-line set of instructions P
<ZeroOne>	I'm gonna read back from the top. Might make what I need to do a little clearer
<ZeroOne>	yep, that's a lot of stuff
<Silver_Skree>	aw come on
<Silver_Skree>	plex plz
<Silver_Skree>	I had to leave off in the middle of an episode
<Silver_Skree>	now it's just hanging up and not doing anything when I ask it to resume
<Silver_Skree>	arrrgh
<Silver_Skree>	and when I play from beginning and try to just seek there it exits out of playing
<Silver_Skree>	|
 *	Silver_Skree tries web client
 *	Silver_Skree gets beginning of episode anyway
<Silver_Skree>	fuck it, I'll watch from the beginning again.
<Silver_Skree>	grr.
<ZeroOne>	Oh, let's see if I can get this
<ZeroOne>	ZrnBot receives some string from the IRC server
<Silver_Skree>	IRC is amazing.
<ZeroOne>	The class that receives it calls a method within MethodFactory
<ZeroOne>	MessageFactory*
<Silver_Skree>	it's so oooold
<Silver_Skree>	and yet
<ZeroOne>	MessageFactory implements the IMessageFactory interface which defines a method that returns an IMessage
<Silver_Skree>	here we are writing clients for it
<ZeroOne>	Message implements IMessage
<ZeroOne>	So ZrnBot is receiving an input and is using the MessageFactory to create a Message object from that input?
<katsu>	Also, zrn, you've pretty much got it
 *	ZeroOne success
<katsu>	I say pretty much because remember that ZrnBot is using interfaces
<katsu>	<ZeroOne> So ZrnBot is receiving an input and is using the MessageFactory to create a Message object from that input?
<katsu>	changed to
<katsu>	<ZeroOne> So ZrnBot is receiving an input from INetwork and is using the IMessageFactory to create an IMessage object from that input?
<katsu>	So when you construct ZrnBot, it needs two things here
<katsu>	ZrnBot(INetwork network, IMessageFactory messageFactory)
<katsu>	Doing it like that allows ZrnBot to use any INetwork or any IMessageFactory
<katsu>	which
<katsu>	. Enables freedom to swap internal implementations without modifying ZrnBot
<ZeroOne>	That seems like a step towards connecting to multiple networks
<katsu>	. Allows easy testing of the ZrnBot class
<katsu>	So to connect to multiple networks, you have to add a few different things
<katsu>	depending on what kind of interaction you want between networks
<ZeroOne>	zero
<katsu>	Then it is fairly trivial
<katsu>	have multiple ZrnBots
<ZeroOne>	Yeah, I figured
<ZeroOne>	I think what I'll do is, sometime today (i.e., after I've gone to bed and woken up), I'll figure out what the Network class actually needs, given I've been told that I've been thinking too low-level with streams
<ZeroOne>	I mean, I imagine I'll need streams eventually
<katsu>	That's going to be in the implementation of INetwork
<katsu>	the interface just needs an event and a method
<katsu>	event is fired on recieving a message
<ZeroOne>	Which I've already written
<ZeroOne>	The event, that is
<katsu>	method sends a string to the server
<katsu>	That's it, interface is done
<ZeroOne>	Whee
<katsu>	Now an implementation, that's where it gets interesting
<katsu>	For testing, you can make a fake INetwork implementation that fires events and checks what ZrnBot sends without touching the network
<katsu>	For the implementation, you'd make a class that takes a uri and establishes a connection to it
 *	KentaTworodani has quit (Ping timeout  seconds)
<katsu>	likely using a System.Net.NetworkStream
<ZeroOne>	Ah, the Bot class is going to hold a reference to an INetwork, which will allow it to subscribe to the "input received" event
<ZeroOne>	But what about the UI?
<katsu>	yeah
<ZeroOne>	Oh, never mind
<ZeroOne>	The way I currently have it, the UI instantiates the Bot class.
<ZeroOne>	Possibly not what it should be doing, but that'd certainly make it able to subscribe
<TheFleetingDuck>	going to bed. night aLL
<ZeroOne>	Night
<ZeroOne>	I'll be off soon too
 *	TheFleetingDuck has quit (Quit Leaving)
<katsu>	So, for the UI, that becomes a completely different thing
<katsu>	That should follow MVVM
<katsu>	Model View ViewModel
<katsu>	Where ZrnBot is a Model
<katsu>	Or may just be one part of some model class
<ZeroOne>	But I do definitely need to separate the UI from the bot initialisation
 *	KentaKurodani (~Kenta-PC@---.res.bhn.net) has joined #sr
 *	ChanServ sets modes [#sr +o KentaKurodani]
<Silver_Skree>	wait, GUI, or are we talking about a console that uses MVVM?
<ZeroOne>	Console
<Silver_Skree>	heh
<Silver_Skree>	okay then
<katsu>	Ah, that's probably simpler
<katsu>	MVVM may be a bit much
<ZeroOne>	But, if I write it correctly (possible an IUserInterface), I probably could quite easily swap it out with an actual GUI
<Silver_Skree>	I was gonna say
<Silver_Skree>	it's not like you can't do MVVM with a console
<katsu>	Well, you see, with MVVM, you'd not have ZrnBot know about any UI
<katsu>	ZrnBot would just mess with data
<katsu>	and only data
<katsu>	The ViewModel would observe the data ZrnBot is changing and notify the View
<katsu>	let me rephrase that
<katsu>	The ViewModel would observe and transform the data ZrnBot is changing and notify the View
<ZeroOne>	Uni had an app where it had a ConsoleUI that implemented IUserInterface. It was written to the point where they could just swap in a proper WinForms UI and implement the same interface
<ZeroOne>	But I don't think it was MVVM
<katsu>	It most certainly was not
<katsu>	a model relies on nothing but other models
<katsu>	viewmodels rely on models
<ZeroOne>	Ah, so if I wanted to remove the Console UI and replace it with WinForms/WPF, I'd need to make it MVVM
<katsu>	and views are (in WPF) loosely connected to viewmodels
<katsu>	So let's say you wanted ZrnBot to be able to output debug info to a window
<katsu>	You'd probably give ZrnBot some sort of ILogger on construction
<katsu>	which would be passed to basically every handler
<katsu>	and they'd log their execution
<katsu>	The console implementation would just do a Console.WriteLine
<katsu>	The MVVM implementation would add the message to some model that the viewmodel would pick up on
<katsu>	and then the view is updated
<katsu>	Essentially, don't have /any/ UI concepts at ZrnBot's level
<katsu>	You don't even have /network/ concepts at ZrnBot's level
<katsu>	ZrnBot processes data that periodically comes in from somewhere
<katsu>	and outputs different types of data
<ZeroOne>	So with a console UI, ZrnBot would hold a reference to an INetwork, but with the GUI, I'd remove that?
<katsu>	INetwork isn't /networking/
<katsu>	INetwork is a declaration of an event and a method
<katsu>	nothing more
<ZeroOne>	Oh, yes
<katsu>	networking happens in a concrete implementation
<ZeroOne>	The actual networking stuff is handled elsewere
<ZeroOne>	I imagine in a Network class?
<katsu>	Yeah, you could call it that
<ZeroOne>	Or possibly Connection class
<katsu>	My IRC library didn't provide an implementation, which is probably a bad call
<ZeroOne>	naughty
<katsu>	You almost always want some basic implementation
<ZeroOne>	So you have an IConnection, but you don't actually have a Connection class?
<katsu>	yep
<katsu>	But the idea was that I was going to intercept commands there and redirect to a bouncer or whatnot
<katsu>	So essentially the IRC library thinks it is talking to a network, but it's talking to a custom bouncer that may use an entirely different communication protocol
<ZeroOne>	Ah
<katsu>	once you've abstracted everything out this far, you can easily add new components without affecting anything else
<ZeroOne>	Now, the Network class should be the class responsible for using the IMessageFactory to create the IMessage on input, shouldn't it?
<katsu>	no
<ZeroOne>	dangit
<katsu>	the responsibility of INetwork is to send and receive strings from /somewhere/
<katsu>	The interface doesn't specify that it should care
<katsu>	It /could/ care
<KentaKurodani>	if there is a nearby local tourney in florida I'm gonna play smash down there too
<ZeroOne>	Oh
<katsu>	The formatting of the data doesn't matter, INetwork doesn't specify
<ZeroOne>	So Network would take the input and fire the event. The UI would print the raw input to the console, while the Bot class uses its IMessageFactory to create the IMessage
<katsu>	if you wanted to specify, you'd have used a different type than string
<ZeroOne>	I think
<katsu>	So an implementation of Network is just
<katsu>	(just a possible implementation)
<katsu>	. Constructor accepts Uri to remote server
<katsu>	. Constructor opens a System.Net.Socket and constructs a System.Net.NetworkStream from that socket
<katsu>	. Contains an async method that loops forever (actually isn't forever, checks a cancellation token to determine whether to end the loop), awaiting a ReadAsync call and converting that to a string and firing the event
<katsu>	. Contains the async method defined by the interface which will await SendAsync after converting the string to a byte array
<katsu>	There you go, done
<katsu>	so what you'd do in your startup
<ZeroOne>	And I'd actually get a chance to use async
<katsu>	var cts = new CancellationToken();
<katsu>	var network = new Network(v"irc.esper.net"), cts.Token);
<katsu>	var zrnBot = new ZrnBot(network, new MessageFactory());
<katsu>	network.StartReadAsync();
<katsu>	// wait until zrnbot is done
<katsu>	cts.Cancel();
<katsu>	bam, done
<ZeroOne>	So network.StartReadAsync(); will just keep it running until I want everything to quit
<katsu>	yeah, essentially
<katsu>	PY might know a bit more about that
<katsu>	There's a bit of black magic going on for the thread pool work
<ZeroOne>	As always.
<ZeroOne>	Now I just need to decouple the startup from the UI in such a way that the UI can still subscribe to the network input received event
<katsu>	simple
<katsu>	ILogger
<katsu>	Don't have the UI subscribe to the input received event
<katsu>	You're essentially using the console to attempt to debug
<katsu>	That's logging
<ZeroOne>	So would Logger subscribe to the input event, and then the UI would subscribe to an event defined by ILogger?
<katsu>	No, you pass the logger to Network on construction
<katsu>	So let's say for your console application you create a class called
<katsu>	class ConsoleLogger  ILogger
<katsu>	where ILogger has the following method
<katsu>	void Log(string message);
<katsu>	and the implementation for ConsoleLogger is
<katsu>	{
<katsu>	    Console.WriteLine(message);
<katsu>	}
<katsu>	done
<katsu>	Now your Network object is "logging" elements, but it doesn't care to where
<katsu>	it just happens that ConsoleLogger is outputting to the console window
<ZeroOne>	So I'd create an instance of ConsoleLogger, then pass it to Network?
<katsu>	yeah
<katsu>	so the startup changes slightly
<katsu>	var logger = new ConsoleLogger();
<katsu>	var cts = CancellationToken();
<ZeroOne>	In which case, my ConsoleUI class is now useless
<katsu>	var network = new Network("", cts.Token, logger);
<katsu>	var zrnBot = new ZrnBot(network, logger, new MessageFactory());
<katsu>	and so on
<katsu>	Well, what does ConsoleUI do?
<ZeroOne>	https//github.com/Zero-One/ZrnBot/blob/master/ZrnBot/ConsoleUI.cs
<OMGbot>	Title ZrnBot/ConsoleUI.cs at master · Zero-One/ZrnBot · GitHub (at https//github.com)
<ZeroOne>	oh, that's outdated
<katsu>	Ok, so you can also do input via console
 *	fredpmpg (~fredpmpg@---.dhcp.leds.al.charter.com) has joined #sr
<katsu>	this gets more complex
<ZeroOne>	No
<katsu>	and your ConsoleLogger becomes more modelly
<ZeroOne>	Console isn't accepting input
<ZeroOne>	http//pastebin.com/Tuuvxj
<OMGbot>	Title [C#] using System; namespace ZrnBot { class ConsoleUI { public - Pastebin.com (at http//pastebin.com)
<katsu>	So then what is GetInput? p
<ZeroOne>	hang on, i've gone braindead
<ZeroOne>	Oh, yes
<ZeroOne>	Yeah, it accepts input for the initial bot setup
<katsu>	ok, so that should just be part of the initialization phase
<katsu>	nothing to do with ZrnBot
<ZeroOne>	I should probably actually push this all to GitHub so you can see what's going on
<ZeroOne>	Ok, repository is updated
<ZeroOne>	So Program creates an instance of the UI and calls ui.Run
<ZeroOne>	That creates a new bot and call its Load method
<ZeroOne>	If it can find a config, it'll load it. Else, it'll do the setup
<ZeroOne>	And the setup calls the static methods in ConsoleUI to make it look nice and pretty and formatted.
<ZeroOne>	Which was my idea of separating the formatting logic from the business logic, until I went and made the ConsoleUI initialise the bot.
<katsu>	Ok, so InputUtils
<katsu>	all of that setup
<katsu>	get that out of the bot
<katsu>	does not belong there
<ZeroOne>	That entire class?
<katsu>	Bot shouldn't be calling anything from InputUtils
<ZeroOne>	Oh
<katsu>	and InputUtils itself is a bit worrying 
<katsu>	Not terrible though
<katsu>	it's decent encapsulation for the various operations you want to perform
<ZeroOne>	So where did I go wrong?
<katsu>	It's the public static nature of that
<katsu>	Those methods should be private on some Startup class
<ZeroOne>	Ah
<ZeroOne>	I'm stuck in the mindset that only objects should be classes.
<ZeroOne>	if that makes sense
<katsu>	Yeah, think of classes simply as responsibilities, not objects
<ZeroOne>	Ah
<ZeroOne>	That makes sense
<ZeroOne>	I need a class responsible for the startup
<katsu>	You have no idea how long it takes for some to pick that up
<katsu>	OOP can really screw with the developer's mindset if that's all they know
<ZeroOne>	Sounds like it should be more responsibility-oriented programming
<katsu>	haha
<katsu>	Well, object is the "correct" term for it
<katsu>	but object carries real-world connotations
<ZeroOne>	So if Bot.Load() can't find a config, it should create an instance of the Startup class and then that'll essentially be the merging of InputUtils and BotSetup
<katsu>	Yeah, sorta
<katsu>	So the bot shouldn't load and save its own configs
<ZeroOne>	I should have a Serialization class to handle that?
<katsu>	There should be a class responsible for reading and writing that
<ZeroOne>	ta-daa
<katsu>	the Startup class would use this to load the bot config, if not found then prompting for bot info
<katsu>	then generates a Bot from that
<katsu>	Essentially, your "mess" is in the Startup class
<katsu>	it is tightly coupled to nearly everything in your program
<katsu>	but the Startup code is very small
<katsu>	so it's not a lot of tightly coupled code to maintain
<katsu>	and in fact, you may not need a separate class for config read/write
<katsu>	or if you do, it'll be very thin
<katsu>	just a wrapper around the existing .NET serialization
<katsu>	It knows about the format of the config file
<katsu>	and you're basically done
<ZeroOne>	So would all of the "var cts = new CancellationToken();" stuff go into this Startup class, or is the Startup class just for the bot?
<katsu>	the Startup class is the one that actually points out what file the config reader/writer should look at
<katsu>	put that in Startup
<katsu>	Once you've got it up and working, we can look at splitting that up
<ZeroOne>	So the Program class is essentially doing var Startup = new Startup();
<katsu>	yeah, pretty much
<ZeroOne>	And then everything kicks off from there
<katsu>	We'll look at splitting it up from there
<ZeroOne>	Right
<ZeroOne>	That doesn't sound terribly difficult to refactor. I might do it now
<katsu>	Startup is a messy thing
<ZeroOne>	He says, wanting to go to bed about an hour ago P
<katsu>	heh
<katsu>	I shouldn't be busy tomorrow, can probably help out
<ZeroOne>	Does it matter if I put all the "var cts..." in the constructor if it's just going to be refactored later? Just as a temporary thing?
<katsu>	The Network constructor needs the cts
<ZeroOne>	I don't have the Network object written yet P
<ZeroOne>	I'm basically refactoring what already exists
<katsu>	https//msdn.microsoft.com/en-us/library/dd(v=vs.).aspx
<katsu>	ah, ok
<katsu>	no need for it yet then
<ZeroOne>	I think my plan is to decouple the UI from the initialisation, which is what I'm doing, then get the Network class working, then start on that factory pattern for the messages
<ZeroOne>	I keep forgetting to close my filestreams
<Silver_Skree>	my brother taught me something good
<Silver_Skree>	any time you write new, go ahead and write its delete as well
<Silver_Skree>	then just move it
<Silver_Skree>	but never get rid of it
<Silver_Skree>	the same idea can be applied to opening and closing stuff
<ZeroOne>	Not a bad idea
<ZeroOne>	Same as pushing and pulling from registers
<katsu>	See, in C++ I try to follow the RAII principle
<katsu>	There is a similar concept in C# with IDisposable objects
<katsu>	Which FileStreams are
<katsu>	using (var file = new FileStream(new File("file")))
<katsu>	{
<katsu>	    file.Write Junk here;
<ZeroOne>	Oh, of course
<katsu>	}
<katsu>	done
<katsu>	C++ has stack-based object destruction that you can utilize
<Silver_Skree>	anyway, speaking of my brother
<Silver_Skree>	DFPercush_ how's Lucia's route going?
<katsu>	and smart pointers in C++ can give you deterministic reference counting that will call the destructor when count hits zero
<ZeroOne>	Ok, refactored
<ZeroOne>	InputUtils now no longer exists
<ZeroOne>	The Bot class isn't in charge of saving, loading or setup
<ZeroOne>	There is a BotSerialiser class that deals with saving and loading
<ZeroOne>	And the Startup class does the bot setup if a FileNotFound exception is thrown on trying to load the bot.
<katsu>	Ok, I'm out for the rest of the day
<katsu>	congrats on the refactoring
<ZeroOne>	Yeah, I think I'm done too P
...
<ZeroOne> Should the connection accept a Uri or two strings and form the Uri itself? Or does it not really matter?
<MenTaLguY> make it a Uri
<MenTaLguY> that way your connection thinger doesn't have to deal with the case where the input isn't a well-formed URI
<MenTaLguY> on the other hand, you might actually want to go further, and have a class that wraps a URI, which you can instantiate only if it's a *well-formed* IRC URI
<MenTaLguY> versus an http// URI or something
<ZrnBot> System.UriFormatException Invalid URI The hostname could not be parsed.
<OMGbot> It's Sunday! Time to post a new Song of the Week!
<ZeroOne> I think I'll go option 
<ZeroOne> If you can't form a proper IRC URI, what are you doing with my bot
<MenTaLguY> making a typo that anyone could make
<ZeroOne> ...
<ZeroOne> ok yeah maybe that could happen
<MenTaLguY> an under-appreciated feature of static type systems is that you can take any assertion you like, check it in a class's constructor, and then that class embodies that assertion at the type level and you don't have to re-check it at runtime, wherever you're using an instance of that class
<ZeroOne> I'll have to consider when to actually check for that
<MenTaLguY> I'd suggest having an IRCUri class (wraps a Uri internally?), and use that everywhere
<MenTaLguY> that way the only place you have to check is in IRCUri's constructor
<ZeroOne> That does sound good. Imma write that down